# Data-Structures-Algorithms-MonoRepo

This repository serves as a centralized codebase documenting my progression as a Computer Scientist . It tracks the transition from high-level scripting to low-level engineering.

The objective is not just to solve LeetCode problems, but to build a personal standard library of data structures and algorithms from the ground up.

## Philosophy: No "Vibe Coding"

As a Student of Higher Education in the modern era, it is easy to "vibe code"â€”relying on heavy abstractions, frameworks, or Copilot suggestions without understanding the underlying mechanics. This repository rejects that approach.

To get *cracked* at engineering, I am strictly avoiding libraries for the core logic. If I need a hash map, I build the hash map. If I need a vector, I manage the memory manually.

The focus is on:
* **Deep Understanding:** Knowing exactly how data is laid out in memory.
* **Algorithmic Complexity:** Prioritizing O(1) and O(log n) over naive O(n) solutions.
* **Systems Thinking:** transitioning from "writing scripts" to "architecting software."

## Roadmap & Structure

The repository is split into two primary distinct distinct streams, handling different languags popular within programming:

### 1. Python (Logic & Architecture)
Used for rapid prototyping of complex algorithms, graph traversal, and high-level architectural patterns.
* **Focus:** Hash Maps, Trees, Graphs, Sorting, Searching.
* **Current Status:** Implementing fundamental linear data structures (Stacks, Queues) to handle data flow.

### 2. C++ (Systems & Memory)
Used to enforce discipline regarding memory management, pointers, and hardware interaction.
* **Focus:** Manual memory management, Pointers/References, STL implementation, Concurrency.
* **Goal:** To move beyond "C with Classes" and master Modern C++ (C++17/20).

## Usage

This is a monorepo. Projects are categorized by language, rather than isolated repositories. This structure allows for code reuse and demonstrates the evolution of my standard library over time.

## A Note on Generative AI

As I am relearning academia level computer science solo - I utilize Generative AI as a rigorous Socratic tutor to review code quality and architecture. While AI tools (like the one used to format this README) handle administrative overhead, the code implementation is manual. The value of this repository lies in the struggle of implementation, not the speed of completion.
